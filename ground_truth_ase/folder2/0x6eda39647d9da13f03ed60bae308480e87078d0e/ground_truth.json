[
  {
    "invariant": "Total token supply equals the sum of all user balances",
    "expression": "totalSupply == Î£(balanceOf[a]) for all a in addresses"
  },
  {
    "invariant": "Sender balance cannot go negative after transfer",
    "expression": "balanceOf[_from] >= _value before _transfer"
  },
  {
    "invariant": "Recipient balance cannot overflow after transfer",
    "expression": "balanceOf[_to] + _value >= balanceOf[_to] before _transfer"
  },
  {
    "invariant": "Transfer does not affect the total amount of tokens",
    "expression": "balanceOf[_from] + balanceOf[_to] remains constant in _transfer"
  },
  {
    "invariant": "Allowance cannot go negative in transferFrom or burnFrom",
    "expression": "allowance[_from][msg.sender] >= _value"
  },
  {
    "invariant": "Only the owner can burn their own tokens",
    "expression": "msg.sender == _from in burnFrom"
  },
  {
    "invariant": "Burn reduces total supply accordingly",
    "expression": "totalSupply decreases by _value in burn and burnFrom"
  },
  {
    "invariant": "approve sets exact value, not additive",
    "expression": "allowance[msg.sender][_spender] == _value after approve"
  },
  {
    "invariant": "approveAndCall performs approve before external call",
    "expression": "approve is successful before calling receiveApproval"
  },
  {
    "invariant": "Cannot transfer to zero address",
    "expression": "_to != 0x0 in _transfer"
  },
  {
    "invariant": "Constructor mints all tokens to creator",
    "expression": "balanceOf[msg.sender] == totalSupply after constructor"
  },
  {
    "invariant": "Decimals remain fixed at 18",
    "expression": "decimals == 18 always"
  }
]

