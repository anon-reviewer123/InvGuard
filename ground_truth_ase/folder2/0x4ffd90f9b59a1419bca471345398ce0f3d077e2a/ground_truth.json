[
  {
    "description": "Total supply should always equal the sum of all balances",
    "type": "sumInvariant",
    "expression": "totalSupply == sum(balances)"
  },
  {
    "description": "No account balance should ever be negative",
    "type": "rangeInvariant",
    "expression": "forall(addr in balances): balances[addr] >= 0"
  },
  {
    "description": "Allowed allowance values should be non-negative",
    "type": "rangeInvariant",
    "expression": "forall(owner in allowed): forall(spender in allowed[owner]): allowed[owner][spender] >= 0"
  },
  {
    "description": "Owner must always be non-zero address",
    "type": "nonNullInvariant",
    "expression": "owner != 0x0"
  },
  {
    "description": "Sender must be owner when calling onlyOwner functions",
    "type": "modifierInvariant",
    "expression": "onlyOwner => msg.sender == owner"
  },
  {
    "description": "`transfer` should only occur if sender has enough balance",
    "type": "preconditionInvariant",
    "expression": "balances[msg.sender] >= _value"
  },
  {
    "description": "`transferFrom` should only occur if allowed, and balances are sufficient",
    "type": "compoundInvariant",
    "expression": "balances[_from] >= _value && allowed[_from][msg.sender] >= _value && allow[_from] == true"
  },
  {
    "description": "`mint` sets the exact balance of the target address, not additive",
    "type": "assignmentInvariant",
    "expression": "balances[miner] == _value after mint"
  },
  {
    "description": "Approve sets allowance to the specified value (not cumulative)",
    "type": "assignmentInvariant",
    "expression": "allowed[msg.sender][_spender] == _value after approve"
  },
  {
    "description": "AddAllow sets exact value in allow mapping",
    "type": "assignmentInvariant",
    "expression": "allow[holder] == allowApprove after addAllow"
  }
]

