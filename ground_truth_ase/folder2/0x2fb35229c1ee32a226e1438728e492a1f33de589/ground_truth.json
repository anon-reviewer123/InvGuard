{
  "invariants": [
    {
      "name": "Total Supply Conservation",
      "description": "Total supply equals the sum of all user balances, including the zero address if applicable.",
      "expression": "_totalSupply == sum(balances[address]) for all address"
    },
    {
      "name": "Non-negative Balances",
      "description": "No account can have a negative balance at any time.",
      "expression": "balances[addr] >= 0 for all addr"
    },
    {
      "name": "Transfer Balance Conservation",
      "description": "Token transfers must preserve total tokens (sender's balance decreases by the same amount as the recipient's increases).",
      "expression": "before_balances[sender] - tokens == after_balances[sender] && before_balances[recipient] + tokens == after_balances[recipient]"
    },
    {
      "name": "Transfer Only With Sufficient Balance",
      "description": "Transfers can only happen if sender has enough balance.",
      "expression": "balances[sender] >= tokens"
    },
    {
      "name": "Allowance Consistency",
      "description": "A spender cannot spend more than their allowance.",
      "expression": "allowed[owner][spender] >= tokens"
    },
    {
      "name": "Approve Sets Allowance",
      "description": "Calling approve updates the allowance to the exact token value.",
      "expression": "approve(spender, tokens) => allowed[msg.sender][spender] == tokens"
    },
    {
      "name": "Zero Address Supply Exclusion",
      "description": "Tokens at the zero address are excluded from totalSupply view.",
      "expression": "totalSupply() == _totalSupply - balances[0x0]"
    },
    {
      "name": "No Overflow on SafeMath",
      "description": "All arithmetic operations using SafeMath should not overflow or underflow.",
      "expression": "safeAdd, safeSub, safeMul, safeDiv revert on overflow or underflow"
    },
    {
      "name": "Transfer Emits Event",
      "description": "Transfers must emit a Transfer event.",
      "expression": "transfer(...) or transferFrom(...) => emits Transfer(sender, recipient, tokens)"
    },
    {
      "name": "Approve Emits Event",
      "description": "Approvals must emit an Approval event.",
      "expression": "approve(...) => emits Approval(owner, spender, tokens)"
    }
  ]
}

