[
  {
    "name": "TotalSupplyConservation",
    "expression": "sum(balances) == totalSupply",
    "description": "The total amount of tokens distributed across all balances should always equal the declared totalSupply."
  },
  {
    "name": "NonNegativeBalances",
    "expression": "∀ addr: balances[addr] >= 0",
    "description": "No account should ever have a negative balance."
  },
  {
    "name": "TransferOnlyWhenNotFrozen",
    "expression": "transfer() ⇒ !frozenAccount[msg.sender] && !frozenAccount[_to]",
    "description": "Transfers should not be allowed if the sender or recipient account is frozen."
  },
  {
    "name": "OnlyOwnerCanFreezeAccounts",
    "expression": "freezeAccount() ⇒ msg.sender == owner",
    "description": "Only the owner is allowed to freeze or unfreeze accounts."
  },
  {
    "name": "TransferObeysAllowance",
    "expression": "transferFrom() ⇒ allowed[_from][msg.sender] >= _value",
    "description": "Transfer from an account is limited by the approved allowance."
  },
  {
    "name": "AllowanceNonNegative",
    "expression": "∀ (owner, spender): allowed[owner][spender] >= 0",
    "description": "Allowances must never be negative."
  },
  {
    "name": "ApproveRaceConditionGuard",
    "expression": "approve(_spender, _value) ⇒ (_value == 0 || allowed[msg.sender][_spender] == 0)",
    "description": "Allowance can only be set if the current allowance is 0 or the new value is 0, to prevent race conditions."
  },
  {
    "name": "OwnershipOnlyTransferredByOwner",
    "expression": "transferOwnership() ⇒ msg.sender == owner && newOwner != 0x0",
    "description": "Only the current owner can transfer ownership to a valid (non-zero) address."
  },
  {
    "name": "LiquidityTransferSwitch",
    "expression": "transfer() ⇒ transferable == true",
    "description": "Transfers are only allowed when the token's liquidity switch is enabled."
  },
  {
    "name": "InitialBalanceToOwner",
    "expression": "constructor ⇒ balances[owner] == totalSupply",
    "description": "Upon deployment, the total supply is assigned to the contract's creator."
  },
  {
    "name": "FallbackFunctionRejectsEther",
    "expression": "fallback ⇒ revert",
    "description": "The fallback function should reject any incoming ether by reverting the transaction."
  }
]

