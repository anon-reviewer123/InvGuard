{
  "invariants": [
    {
      "name": "Total Supply Invariant",
      "description": "Total supply equals the sum of all balances.",
      "expression": "totalSupply == sum(balanceOf[a] for all a)"
    },
    {
      "name": "Transfer Overflow Protection",
      "description": "Transfers must not cause overflows in recipient balances.",
      "expression": "balanceOf[_to] + _value >= balanceOf[_to]"
    },
    {
      "name": "No Transfer to Zero Address",
      "description": "Tokens must not be sent to the zero address.",
      "expression": "_to != 0x0"
    },
    {
      "name": "Frozen Accounts Cannot Send or Receive",
      "description": "Frozen accounts cannot participate in token transfers.",
      "expression": "!frozenAccount[_from] && !frozenAccount[_to]"
    },
    {
      "name": "Owner Set On Deployment",
      "description": "Owner is set to deployer address at contract creation.",
      "expression": "owner == msg.sender (during constructor execution)"
    },
    {
      "name": "Ownership Transfer Only By Owner",
      "description": "Only the current owner can transfer ownership.",
      "expression": "msg.sender == owner (inside transferOwnership)"
    },
    {
      "name": "New Owner Cannot Be Zero Address",
      "description": "Ownership cannot be transferred to address(0).",
      "expression": "newOwner != 0x0"
    },
    {
      "name": "Sender Has Sufficient Balance",
      "description": "Sender must have at least the amount they want to transfer.",
      "expression": "balanceOf[_from] >= _value"
    },
    {
      "name": "Preserve Total Balance",
      "description": "Sum of balances between sender and receiver remains constant (unless burning/minting).",
      "expression": "balanceOf[_from] + balanceOf[_to] == previousBalances"
    },
    {
      "name": "TransferFrom Respects Allowance",
      "description": "Allowance must be sufficient for transferFrom to succeed.",
      "expression": "_value <= allowance[_from][msg.sender]"
    },
    {
      "name": "Decrease Allowance After Use",
      "description": "Allowance is reduced by _value after transferFrom.",
      "expression": "allowance[_from][msg.sender] -= _value"
    },
    {
      "name": "Burner Has Enough Tokens",
      "description": "Caller must have at least the amount of tokens they want to burn.",
      "expression": "balanceOf[msg.sender] >= _value"
    },
    {
      "name": "Burn Reduces Total Supply",
      "description": "Total supply decreases by burned amount.",
      "expression": "totalSupply == previousTotalSupply - _value"
    },
    {
      "name": "Frozen Account Cannot Send",
      "description": "Frozen accounts are restricted from transferring tokens.",
      "expression": "!frozenAccount[_from]"
    },
    {
      "name": "Frozen Account Cannot Receive",
      "description": "Frozen accounts are restricted from receiving tokens.",
      "expression": "!frozenAccount[_to]"
    },
    {
      "name": "Buy Price > 0",
      "description": "Buy price should be a positive value.",
      "expression": "buyPrice > 0"
    },
    {
      "name": "Sell Price >= 0",
      "description": "Sell price should be a non-negative value.",
      "expression": "sellPrice >= 0"
    },
    {
      "name": "Contract Has Enough ETH to Buy Tokens Back",
      "description": "The contract must have enough Ether to fulfill the sell order.",
      "expression": "this.balance >= amount * sellPrice"
    },
    {
      "name": "Only Owner Can Freeze Accounts",
      "description": "Only the contract owner can freeze or unfreeze accounts.",
      "expression": "msg.sender == owner"
    },
    {
      "name": "Only Owner Can Set Prices",
      "description": "Only the contract owner can update buy/sell prices.",
      "expression": "msg.sender == owner"
    }
  ]
}

