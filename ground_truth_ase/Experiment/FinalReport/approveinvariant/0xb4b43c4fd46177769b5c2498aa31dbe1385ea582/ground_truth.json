[
  {
    "name": "total_supply_consistency",
    "expression": "_totalSupply == sum(balances) + balances[address(0)]",
    "description": "Total supply must always equal the sum of all balances including burned tokens in address(0)."
  },
  {
    "name": "non_negative_balances",
    "expression": "forall addr: balances[addr] >= 0",
    "description": "All token balances must be non-negative."
  },
  {
    "name": "non_negative_allowances",
    "expression": "forall (owner, spender): allowed[owner][spender] >= 0",
    "description": "All allowances must be non-negative."
  },
  {
    "name": "transfer_preserves_total_balance",
    "expression": "before(balances[sender] + balances[recipient]) == after(balances[sender] + balances[recipient])",
    "description": "A transfer must preserve the total tokens between sender and recipient."
  },
  {
    "name": "transferFrom_preserves_total_balance",
    "expression": "before(balances[from] + balances[to]) == after(balances[from] + balances[to])",
    "description": "A transferFrom must preserve the total tokens between from and to."
  },
  {
    "name": "valid_allowance_decrement",
    "expression": "allowed[from][spender] >= tokens in transferFrom",
    "description": "Spender can only transfer up to the approved allowance."
  },
  {
    "name": "only_owner_can_call_onlyOwner",
    "expression": "msg.sender == owner in onlyOwner",
    "description": "Only the current owner can call functions restricted by the onlyOwner modifier."
  },
  {
    "name": "ownership_transfer_safety",
    "expression": "owner != newOwner || newOwner == 0x0 before transferOwnership",
    "description": "Ownership cannot be transferred to the same address or a zero address."
  },
  {
    "name": "ownership_accept_requires_newOwner",
    "expression": "msg.sender == newOwner in acceptOwnership",
    "description": "Only the pending new owner can accept ownership."
  },
  {
    "name": "approve_sets_allowance_correctly",
    "expression": "allowed[owner][spender] == tokens after approve",
    "description": "Approve correctly sets the allowance from owner to spender."
  },
  {
    "name": "approveAndCall_executes_callback",
    "expression": "ApproveAndCallFallBack(spender).receiveApproval is invoked",
    "description": "approveAndCall must invoke the receiver contractâ€™s receiveApproval function."
  },
  {
    "name": "no_ether_accepted",
    "expression": "fallback() reverts on msg.value > 0",
    "description": "The contract should not accept ETH transfers."
  },
  {
    "name": "token_rescue_only_by_owner",
    "expression": "msg.sender == owner in transferAnyERC20Token",
    "description": "Only the owner can transfer out accidentally sent tokens."
  },
  {
    "name": "event_emission_transfer",
    "expression": "Transfer event is emitted with correct parameters after any transfer",
    "description": "Each token transfer must emit a Transfer event with the correct parameters."
  },
  {
    "name": "event_emission_approval",
    "expression": "Approval event is emitted with correct parameters after approval",
    "description": "Each approval must emit an Approval event with the correct parameters."
  }
]

