[
  {
    "name": "Total Supply Constant",
    "description": "The total supply of tokens should always equal the sum of all user balances (excluding zero address).",
    "expression": "_totalSupply == sum(balances[addr] for addr in all_addresses if addr != 0x0)"
  },
  {
    "name": "Initial Owner Allocation",
    "description": "The owner should initially be assigned the entire token supply.",
    "expression": "balances[0x2496f5a116816D48269595fd75bed536BF193ecf] == _totalSupply"
  },
  {
    "name": "Non-negative Balances",
    "description": "All token balances should always remain non-negative.",
    "expression": "forall addr: balances[addr] >= 0"
  },
  {
    "name": "Non-negative Allowances",
    "description": "All allowances should be non-negative.",
    "expression": "forall owner, spender: allowed[owner][spender] >= 0"
  },
  {
    "name": "Transfer Safety",
    "description": "No user should be able to transfer more tokens than they own.",
    "expression": "transfer(to, tokens): require(balances[msg.sender] >= tokens)"
  },
  {
    "name": "TransferFrom Safety",
    "description": "No transferFrom call should exceed allowance or sender's balance.",
    "expression": "transferFrom(from, to, tokens): require(balances[from] >= tokens && allowed[from][msg.sender] >= tokens)"
  },
  {
    "name": "Zero Address Burn Exclusion",
    "description": "Tokens at the zero address are considered burned and excluded from total supply.",
    "expression": "totalSupply() == _totalSupply - balances[0x0]"
  },
  {
    "name": "Approval Consistency",
    "description": "Approving a spender sets the allowance to the specified value exactly.",
    "expression": "approve(spender, tokens): allowed[msg.sender][spender] == tokens"
  },
  {
    "name": "Event Emission",
    "description": "Transfer and approval operations must emit the corresponding events.",
    "expression": "transfer/transferFrom: emits Transfer; approve: emits Approval"
  },
  {
    "name": "Fallback Reverts",
    "description": "Contract must not accept ETH via fallback.",
    "expression": "fallback(): always reverts"
  }
]

