{
  "invariants": [
    {
      "type": "supply",
      "description": "Total supply equals the sum of all balances",
      "expression": "totalSupply == sum(balanceOf[all_addresses])"
    },
    {
      "type": "transfer",
      "description": "Transfer should not create or destroy tokens",
      "expression": "balanceOf[_from] + balanceOf[_to] == previousBalances"
    },
    {
      "type": "transfer",
      "description": "Recipient cannot be zero address",
      "expression": "_to != 0x0"
    },
    {
      "type": "transfer",
      "description": "Sender must have enough tokens",
      "expression": "balanceOf[_from] >= _value"
    },
    {
      "type": "transfer",
      "description": "Overflow not allowed when receiving tokens",
      "expression": "balanceOf[_to] + _value > balanceOf[_to]"
    },
    {
      "type": "burn",
      "description": "Tokens removed from balance and total supply",
      "expression": "balanceOf[_from] -= _value && totalSupply -= _value"
    },
    {
      "type": "burn",
      "description": "Caller must have enough balance to burn",
      "expression": "balanceOf[_from] >= _value"
    },
    {
      "type": "burnFrom",
      "description": "Allowance must cover the burn amount",
      "expression": "allowance[_from][msg.sender] >= _value"
    },
    {
      "type": "approval",
      "description": "Setting allowance updates correctly",
      "expression": "allowance[msg.sender][_spender] == _value"
    },
    {
      "type": "approval",
      "description": "approveAndCall triggers spender callback after approval",
      "expression": "approve(_spender, _value) && spender.receiveApproval(msg.sender, _value, this, _extraData)"
    },
    {
      "type": "arithmetic",
      "description": "No underflows in balance subtraction",
      "expression": "balanceOf[_from] >= _value"
    },
    {
      "type": "arithmetic",
      "description": "No overflows on addition",
      "expression": "balanceOf[_to] + _value > balanceOf[_to]"
    },
    {
      "type": "arithmetic",
      "description": "Invariant preserved during _transfer",
      "expression": "assert(balanceOf[_from] + balanceOf[_to] == previousBalances)"
    },
    {
      "type": "constructor",
      "description": "Creator receives full initial supply",
      "expression": "balanceOf[msg.sender] == totalSupply"
    }
  ]
}

