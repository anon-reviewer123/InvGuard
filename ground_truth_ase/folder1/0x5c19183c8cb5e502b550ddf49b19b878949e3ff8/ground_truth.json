{
  "Insured_Finance.sol": {
    "vulnerabilities": ["Arithmetic", "Access Control", "ERC20 Semantic Consistency"],
    "invariants": [
      {
        "description": "Total supply equals sum of all account balances, excluding the zero address.",
        "formal": "_totalSupply == Σ balances[addr] for all addr ≠ address(0)",
        "category": "ERC20 Semantic Consistency"
      },
      {
        "description": "No transfer or transferFrom can exceed sender's balance.",
        "formal": "require(balances[msg.sender] >= tokens) and require(balances[from] >= tokens)",
        "category": "Arithmetic"
      },
      {
        "description": "No transferFrom can exceed approved allowance.",
        "formal": "require(allowed[from][msg.sender] >= tokens)",
        "category": "Access Control"
      },
      {
        "description": "Balance updates must preserve arithmetic correctness (no overflows/underflows).",
        "formal": "balances[to] == safeAdd(previousBalanceTo, tokens)",
        "category": "Arithmetic"
      },
      {
        "description": "Approval value must be exactly what the user intended (no race conditions or additive approvals).",
        "formal": "allowed[msg.sender][spender] = tokens (not +=)",
        "category": "Access Control"
      },
      {
        "description": "Transfer and TransferFrom must emit Transfer event with correct parameters.",
        "formal": "emit Transfer(from, to, tokens) must match actual transfer values",
        "category": "ERC20 Semantic Consistency"
      },
      {
        "description": "Approve must emit Approval event reflecting correct allowance.",
        "formal": "emit Approval(owner, spender, tokens) == allowed[owner][spender]",
        "category": "ERC20 Semantic Consistency"
      }
    ]
  }
}

