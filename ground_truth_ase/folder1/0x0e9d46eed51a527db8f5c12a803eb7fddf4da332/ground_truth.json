{
  "TokenERC20.sol": {
    "vulnerabilities": ["Arithmetic Safety", "Access Control", "Invariant Consistency"],
    "invariants": [
      {
        "description": "The sum of all balances must not exceed totalSupply",
        "formal": "Σ(balanceOf[address]) ≤ totalSupply",
        "category": "Invariant Consistency"
      },
      {
        "description": "The sum of balances before and after a transfer must remain equal",
        "formal": "balanceOf[_from] + balanceOf[_to] == previousBalances",
        "category": "Invariant Consistency"
      },
      {
        "description": "Transfer and burn operations must not underflow sender's balance",
        "formal": "require(balanceOf[msg.sender] >= _value)",
        "category": "Arithmetic Safety"
      },
      {
        "description": "Allowance should not be exceeded during transferFrom or burnFrom",
        "formal": "_value ≤ allowance[_from][msg.sender]",
        "category": "Access Control"
      },
      {
        "description": "Transfers must not be sent to the zero address",
        "formal": "_to ≠ 0x0",
        "category": "Access Control"
      },
      {
        "description": "Token approvals must emit Approval events for traceability",
        "formal": "Approval(msg.sender, _spender, _value) must be emitted after approval",
        "category": "Auditability"
      },
      {
        "description": "Total supply must decrease by the burned amount",
        "formal": "totalSupply_post = totalSupply_pre - _value",
        "category": "Invariant Consistency"
      },
      {
        "description": "Token creation must assign entire initial supply to contract creator",
        "formal": "balanceOf[msg.sender] = totalSupply (at deployment)",
        "category": "Initialization"
      }
    ]
  }
}

