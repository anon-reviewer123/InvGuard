[
  {
    "description": "Sum of all balances (excluding address(0)) equals totalSupply",
    "expression": "sum(balances[addr] for addr in all_addresses if addr != 0x0) == _totalSupply"
  },
  {
    "description": "Total supply reported by totalSupply() matches internal _totalSupply minus balance of address(0)",
    "expression": "totalSupply() == _totalSupply - balances[0x0]"
  },
  {
    "description": "Initial supply is assigned to contract creator",
    "expression": "balances[contract_creator] == _totalSupply"
  },
  {
    "description": "Token transfers do not create or destroy tokens",
    "expression": "before_total == after_total where before_total = balances[from] + balances[to] and after_total = balances[from]' + balances[to]'"
  },
  {
    "description": "Sender balance decreases by transferred amount on transfer",
    "expression": "balances[msg.sender]' == balances[msg.sender] - tokens"
  },
  {
    "description": "Recipient balance increases by transferred amount on transfer",
    "expression": "balances[to]' == balances[to] + tokens"
  },
  {
    "description": "Approval sets spender allowance correctly",
    "expression": "allowed[msg.sender][spender]' == tokens"
  },
  {
    "description": "Allowance decreases on transferFrom",
    "expression": "allowed[from][msg.sender]' == allowed[from][msg.sender] - tokens"
  },
  {
    "description": "Only spender can call transferFrom using their allowance",
    "expression": "msg.sender == spender when calling transferFrom"
  },
  {
    "description": "Cannot transfer more than balance",
    "expression": "tokens <= balances[msg.sender]"
  },
  {
    "description": "Cannot transferFrom more than allowed",
    "expression": "tokens <= allowed[from][msg.sender]"
  }
]

