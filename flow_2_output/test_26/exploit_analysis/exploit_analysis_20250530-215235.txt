Exploit Analysis Report
Generated At: 2025-05-30 21:52:35

================================================================================
ORIGINAL CONTRACT CODE
================================================================================
pragma solidity ^0.4.15;

contract Reentrance {
    mapping (address => uint) userBalance;

    function getBalance(address u) constant returns(uint){
        return userBalance[u];
    }

    function addToBalance() payable{
        userBalance[msg.sender] += msg.value;
    }

    function withdrawBalance(){
        // send userBalance[msg.sender] ethers to msg.sender
        // if mgs.sender is a contract, it will call its fallback function
        // <yes> <report> REENTRANCY
        if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){ 
            throw;
        }
        userBalance[msg.sender] = 0;
    }
}

================================================================================
VULNERABILITIES FOUND
================================================================================
Reentrancy: The contract is vulnerable to reentrancy attacks due to the use of `call.value` in the `withdrawBalance` function. This allows an attacker to recursively call the `withdrawBalance` function before the state update occurs.

================================================================================
EXPLOIT DETAILS
================================================================================
1. An attacker deposits some ether into the contract using `addToBalance`.
2. The attacker then calls `withdrawBalance`, which invokes a malicious fallback function.
3. The fallback function reenters the `withdrawBalance` function before the user balance is set to zero.
4. This allows the attacker to drain funds from the contract in multiple recursive calls.
