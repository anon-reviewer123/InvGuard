Exploit Analysis Report
Generated At: 2025-05-30 21:50:32

================================================================================
ORIGINAL CONTRACT CODE
================================================================================
pragma solidity ^0.4.18;

contract Reentrance {

  mapping(address => uint) public balances;

  function donate(address _to) public payable {
    balances[_to] += msg.value;
  }

  function balanceOf(address _who) public view returns (uint balance) {
    return balances[_who];
  }

  function withdraw(uint _amount) public {
    if(balances[msg.sender] >= _amount) {
      // <yes> <report> REENTRANCY
      if(msg.sender.call.value(_amount)()) {
        _amount;
      }
      balances[msg.sender] -= _amount;
    }
  }

  function() public payable {}
}

================================================================================
VULNERABILITIES FOUND
================================================================================
1. Reentrancy: The contract is vulnerable to reentrancy attacks due to the improper order of operations in the `withdraw` function.
2. Access Control: There is no check to ensure that only the intended recipient can call certain functions.

================================================================================
EXPLOIT DETAILS
================================================================================
1. **Attack Flow:**
   - The attacker donates some ether to the contract to establish a balance.
   - The attacker then calls the `withdraw` function, initiating a withdrawal.
   - Due to the reentrancy vulnerability, the contract allows multiple recursive calls before updating the balance.
   - The attacker can repeatedly invoke `withdraw` before the balance is deducted, draining the contract.

2. **Impact:**
   - Complete loss of funds for the contract.
   - Violation of the fundamental security property: **Consistency** (contract state remains valid after execution).

3. **Exploit Scenario:**
   - Attacker donates 1 ETH, then calls `withdraw(1 ether)` recursively until the balance is depleted.
